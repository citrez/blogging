---
title: Be smart with file manipulation
author: R package build
date: '2021-03-23'
slug: be-smart-with-file-manipulation
categories: ["file system"]
tags: ["R","file system"]
draft: true
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

Classic problem I stumbled across recently. I had a bunch of files in a directory, and i wanted to rename them all at once. Perfect excuse, i  thought to myself, to check out the fs (in R) package for manipulating files.

## What is a file what is a directory

Good to be clear at the offset. A directory is where you store your files. 
They call it a tree structure, because it looks like a tree. Take a look at one of the directories used to make this blog. 

```{r}
fs::dir_tree('..',recurse = F)
```

fs has a set of functions to deal with both files and directories. 

## What is the game?

The game is very simple, creating, deleting, moving and changing the name of files and directories. That's it, its not rocket science. Its very simple, im sure you've all done all of these things before. All we are going to discuss is a different (more automatable) way of doing these things, in the hope that it will save you time for large batch jobs. 

# create a folder to play with 

First, lets see where you are. With computers, at any given point you are somewhere in your machine. Where are you? well you can find out using path_wd()
```{r}
library(fs)
fs::path_wd()
```

lets make a directory, called tester
```{r}
dir_create("tester")
```

lets put 10 folders in, called folder_1, folder_2 etc. Here comes the power of working with fs rather than doing things manually. Now we can just loop, or create with vectorised operations. 
```{r}

dir_create( path("tester",paste0("folder_",1:10) ) )

```

if we wanted to delete a few, its be just as easy.
```{r}
dir_delete(path("tester",paste0("folder_",6:10) ))
```

```{r}
fs::file_create(path("tester","folder_1","my_file",ext = "csv"))
```


inspect files using a tree
```{r}
fs::dir_tree("tester",recurse = T)
```


another way of looking is to chuck it into a dataframe to get all the info. this has the file path, whether it is a file or dir, the size, permissions, when it was last modified and more...
```{r}
fs::dir_info("tester") 
```

lets end off this exploration by leaving no trace and deleting our tester directory
```{r}
dir_delete("tester")
```


Done. 

## manipulate file paths

If you ever thought, ' i cant be bother to write out "my/path/to/my/file/file.txt", let `fs::path()` do the work `fs::path("my/path/to","my","file","file", ext = "txt")` the benefit here, as with all fs functions, they are vectorised. So if you wanted to make 20 file path in the same directory called my/path/to/my/file/file1.txt,my/path/to/my/file/file2.txt .. etc its as simple as  `fs::path("my/path/to","my","file","file",1:20, ext = "txt")`. Vectorised functions are an important thing to understand in R, but once you understand vectorised functions, it'll change the way you understand R - check out my thoughts about it here. 

 `fs::path_wd()` is tells you where you are. 
 `fs::dir_ls('.')` is also your friend, it tell what is in the place you are in.

```{r,eval = F}

library(fs)


old_path <- fs::dir_ls('..')[1:3]
new_path <- fs::dir_ls('..')[1:3] %>% str_remove("(?<=\\.{2}/)\\d{4}-\\d{2}-\\d{2}-")


#fs::file_move(path = old_path,new_path = new_path)

fs::path("my/path/to","my","file","file", ext = "txt")

dir_info(path = '.') # can add recurse = TRUE
dir_ls('..')

fs::file_move(path = fs::dir_ls('.') ,
              new_path =  str_remove_all( fs::dir_ls('.'), '\\d*' ) )



#construct paths
path('my','file','path',ext = 'txt')

file_show('index.Rmd')
```

